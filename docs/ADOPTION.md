# Adoption Guide

This guide helps teams adopt wetwire-github alongside existing workflows or migrate from raw YAML.

## Migration Strategies

### Side-by-Side Adoption

wetwire-github generates standard GitHub Actions YAML, so you can adopt it incrementally. Your repository can have both:

- **Hand-written YAML** in `.github/workflows/`
- **Generated YAML** from Python declarations

```
.github/workflows/
├── ci.yml              # Generated by wetwire-github
├── deploy.yml          # Generated by wetwire-github
└── legacy-release.yml  # Hand-written, not yet migrated
```

The generated files are standard YAML - GitHub Actions doesn't know or care how they were created.

### Incremental Migration Path

**Week 1: Proof of Concept**
- Import one simple workflow using `wetwire-github import`
- Review the generated Python code
- Rebuild it with `wetwire-github build`
- Verify the output matches the original

**Week 2-4: Build Confidence**
- Migrate 2-3 more workflows
- Start writing new workflows in Python
- Run linting on all Python workflows

**Ongoing:**
- New workflows always in Python
- Opportunistic migration of legacy workflows
- Refactor common patterns into reusable jobs/steps

### What NOT to Migrate (Yet)

- **Complex matrix workflows** with many conditional expressions
- **Workflows with heavy bash scripts** (keep scripts external)
- **Workflows managed by other teams** (coordinate first)
- **Working production workflows** with no planned changes

If it's not broken and you're not changing it, don't migrate it.

## Using the Import Command

The fastest way to migrate existing workflows:

```bash
# Import a single workflow
wetwire-github import .github/workflows/ci.yml -o ci/

# Import all workflows
wetwire-github import .github/workflows/*.yml -o ci/

# Import without project scaffolding
wetwire-github import .github/workflows/ci.yml --no-scaffold -o ci/

# Generate single file (simpler for small projects)
wetwire-github import .github/workflows/ci.yml --single-file -o ci/
```

### Import Output Structure

```
ci/
├── __init__.py
├── workflows.py    # Workflow definitions
├── jobs.py         # Job definitions
└── steps.py        # Step sequences
```

### Post-Import Cleanup

After importing, review and improve the generated code:

1. **Replace raw action strings with typed wrappers**
   ```python
   # Before (imported)
   Step(uses="actions/checkout@v4")

   # After (improved)
   from wetwire_github.actions import checkout
   checkout()
   ```

2. **Extract secrets with Secrets context**
   ```python
   # Before (imported)
   env={"TOKEN": "${{ secrets.GITHUB_TOKEN }}"}

   # After (improved)
   from wetwire_github.workflow.expressions import Secrets
   env={"TOKEN": Secrets.get("GITHUB_TOKEN")}
   ```

3. **Run the linter to find issues**
   ```bash
   wetwire-github lint ci/
   wetwire-github lint ci/ --fix  # Auto-fix what's possible
   ```

## Escape Hatches

For edge cases the library doesn't handle cleanly.

### Raw YAML Passthrough

When you need features not yet supported:

```python
# Use raw dictionaries for unsupported properties
workflow = Workflow(
    name="CI",
    on={"push": {"branches": ["main"]}},  # Raw dict works fine
    jobs={"build": build_job},
)
```

### External Step Scripts

Keep complex bash in external files:

```python
# Instead of inline bash
Step(run="""
  complex
  multi-line
  script
""")

# Use external scripts
Step(run="./scripts/complex-build.sh")
```

### Custom Action Wrappers

For actions without pre-generated wrappers:

```python
from wetwire_github.workflow import Step

def my_custom_action(
    version: str = "v1",
    config_path: str = ".config.yml",
) -> Step:
    """Wrapper for org/custom-action."""
    return Step(
        uses=f"org/custom-action@{version}",
        with_={
            "config-path": config_path,
        },
    )

# Usage
steps = [
    my_custom_action(config_path="custom.yml"),
]
```

### When to Use Each Escape Hatch

| Situation | Approach |
|-----------|----------|
| Unsupported trigger property | Raw dictionary in `on=` |
| Complex conditional expression | String in `if=` |
| Multi-line bash script | External script file |
| Custom organization action | Write a wrapper function |
| Experimental GitHub feature | Raw dictionary/string |

## Team Onboarding

A playbook for getting team members productive in their first week.

### Day 1: Environment Setup

```bash
# Clone and install
git clone <repo>
cd <repo>
uv sync

# Verify setup
wetwire-github --version
wetwire-github list ci/
wetwire-github build ci/ --output /tmp/test/
```

### Day 1-2: Read the Code

1. Start with `ci/workflows.py` - understand the workflow structure
2. Read `ci/jobs.py` - see how jobs are defined
3. Look at `ci/steps.py` - common step patterns
4. Check `.github/workflows/` - see the generated output

### Day 2-3: Make Small Changes

Good first contributions:

- Add a new trigger (e.g., schedule, workflow_dispatch)
- Add environment variables to a job
- Add a new step to an existing job
- Update action versions

```python
# Example: Add workflow_dispatch trigger
workflow = Workflow(
    name="CI",
    on={
        "push": {"branches": ["main"]},
        "workflow_dispatch": {},  # Added
    },
    jobs={"build": build_job},
)
```

### Day 3-4: Add New Resources

- Create a new job with a few steps
- Add the job to an existing workflow
- Build and verify the output

### Day 5: Review Patterns

- Run `wetwire-github lint ci/` on your changes
- Review the team's coding conventions
- Ask questions about patterns you don't understand

### Common Gotchas

**NameError: name 'checkout' is not defined**
```python
# Missing import
from wetwire_github.actions import checkout
```

**Generated YAML has wrong indentation**
```bash
# This shouldn't happen - file an issue
wetwire-github build ci/ -o .github/workflows/
cat .github/workflows/ci.yml
```

**Matrix not expanding correctly**
```python
# Use Matrix.get() for matrix references
from wetwire_github.workflow.expressions import Matrix

runs_on = Matrix.get("os")  # Not ${{ matrix.os }}
```

### Team Conventions

1. **File organization**: One workflow per file in `workflows.py`
2. **Naming**: Use snake_case for Python, the library converts to kebab-case
3. **Jobs**: Define reusable jobs in `jobs.py`
4. **Steps**: Extract common step sequences to `steps.py`
5. **Actions**: Use typed wrappers when available

## Integration Patterns

### With Existing CI/CD

If you have other CI/CD tools:

```yaml
# .github/workflows/trigger-external.yml (hand-written)
name: Trigger External CI
on:
  workflow_run:
    workflows: ["CI"]  # Generated by wetwire-github
    types: [completed]
steps:
  - run: curl -X POST $EXTERNAL_CI_URL
```

### With Dependabot

wetwire-github can also manage Dependabot configuration:

```python
from wetwire_github.dependabot import Dependabot, Update, Schedule

dependabot = Dependabot(
    version=2,
    updates=[
        Update(
            package_ecosystem="pip",
            directory="/",
            schedule=Schedule(interval="weekly"),
        ),
    ],
)
```

### With Issue Templates

```python
from wetwire_github.issue_templates import IssueTemplate, Input, Textarea

bug_report = IssueTemplate(
    name="Bug Report",
    description="Report a bug",
    body=[
        Input(
            label="Version",
            description="What version are you using?",
        ),
        Textarea(
            label="Description",
            description="Describe the bug",
        ),
    ],
)
```

## See Also

- [Quick Start](QUICK_START.md) - Get started in 5 minutes
- [CLI Reference](CLI.md) - All CLI commands
- [Import Workflow](IMPORT_WORKFLOW.md) - Detailed import guide
- [Lint Rules](LINT_RULES.md) - Code quality rules
- [Examples](EXAMPLES.md) - Real-world examples
